#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct calElement
{
	char*day;
	int date;
	char*activity;
};
struct calElement*create()
{
	struct calElement*calendar;
	calendar=(struct calElement*)malloc(sizeof(struct calElement)*7);
	return calendar;
}
void read(struct calElement*calendar)
{
	char day[10];
	char activity[25];
	int i, date;
	for(i=0; i<7;i++)
	{
		printf("Enter the day:");
		scanf("%s",day);
		calendar[i].day=(char*)malloc(strlen(day)+1);
		strcpy(calendar[i].day,day);
		printf("Enter the date:");
		scanf("%d",&date);
		calendar[i].date=date;
		getchar();
		printf("Enter description of the activity:");
		scanf("%[^\n]s",activity);
		calendar[i].activity=(char*)malloc(strlen(activity)+1);
		strcpy(calendar[i].activity,activity);
	}
}
void display(struct calElement*calendar)
{
	int i;
	printf("\n\n Your calendar:\n");
	printf("Day\t\tDate\t\tActivity");
	for(i=0; i<7; i++)
	{
		printf("\n%s\t\t%d\t\t%s",calendar[i].day,calendar[i].date,calendar[i].activity);
	}
}
void main()
{
	struct calElement*calendar;
	calendar=create();
	read(calendar);
	display(calendar);
	free(calendar);
}
2.
#include<stdio.h>
char str[100], pat[50], rep[50], ans[100];
int i, j, c, m, k, flag=0;
void stringmatch()
{
	i=m=c=j=0;
	while(str[c]!='\0')
	{
		if(str[m]==pat[i])
		{
			i++; m++;
			if(pat[i]=='\0')
			{
				flag=1;
				for(k=0; rep[k]!='\0';k++,j++)
				ans[j]=rep[k];
				i=0;
				c=m;
			}
		}
		else
		{
			ans[j]=str[c];
			j++;
			c++;
			m=c;
			i= 0;
		}//else ends
	} //end of while
	ans[j]='\0';
} //end stringmatch()

void main()
{
	
	printf("\nEnter a main string \n");
	gets(str);
	printf("\nEnter a pattern string \n");
	gets(pat);
	printf("\nEnter a replace string \n");
	gets(rep);
	stringmatch();
	if(flag==1)
	printf("\nThe resultant string is\n %s" , ans);
	else
	printf("\nPattern string NOT found\n")
}
3.
#include<stdio.h>
#define MAX 4
int top = -1;
void push(int stack[], int item)
{
	if(top == (MAX-1))
	printf("\n\nStack is Overflow");
	else
	{
		stack[++top] = item;
	}
}
void pop(int stack[])
{
	int ret;
	if(top == -1)
	printf("\n\nStack is Underflow");
	else
	{
		ret = stack[top--];
		printf("\nPopped element is %d", ret);
	}
}
void palindrome(int stack[])
{
	int i,k, temp;
	temp=k=top;
	if(top == -1)
	printf("\n\nStack is Empty");
	else
	{
		for(i=0; i<temp; i++)
		{
			if(stack[i] != stack[k--])
			break;
		}
		if(i==temp)
		printf("\nStack contents are Palindrome");
		else
		printf("\nStack contents are not palindrome");
	}
}
void display(int stack[])
{
	int i;
	if(top == -1)
	printf("\nStack is Empty");
	else
	{
		printf("\nThe stack contents are:");
		for(i=top; i>=0; i--)
		printf("\n\n-----| %d |----", stack[i]);
		printf("\n");
	}
}
void main()
{
int item,stack[MAX],ch;

while(1)
{
printf("\n\n----MAIN MENU----\n");
printf("\n1.PUSH");
printf("\n2.POP");
printf("\n3.PALINDROME");
printf("\n4.Exit");
printf("\nEnter Your Choice: ");
scanf("%d", &ch);
switch(ch)
{
	case 1: printf("\nEnter a element to be pushed: ");
	scanf("%d", &item);
	push(stack, item);
	display(stack);
	break;
	case 2:pop(stack);
	if(top!=-1)
	display(stack);
	break;
	case 3:
	palindrome(stack);
	break;
	case 4:
	exit(0); break;
	default:printf("\nInvalid choice \n");
 }
}
}
4.
 #include<stdio.h>
#include<string.h>

int top;
void push(char stack[],char ele)
{
	stack[++top]=ele;
}
char pop(char stack[])
{
	return stack[top--];
}
char stacktop(char stack[])
{
	return(stack[top]);
}

int precd(char op)
{
	switch(op)
	{
		case'^':return 3;
		case'*':
		case'/':
		case'%':return 2;
		case'+':
		case'-':return 1;
		case'(':return 0;
		default:return 0;
	}
}
void infix_postfix(char infix[],char postfix[])
{
	char symb,stack[40];
	int i=0;int j=0;
	top=-1;
	while(infix[i]!='\0')
	{
		symb=infix[i++];
		if(isalpha(symb)||isdigit(symb))
			postfix[j++]=symb;

			else if(symb=='(')
			push(stack,'(');
			else if(symb==')')
			{
			while(stacktop(stack)!='(')
			postfix[j++]=pop(stack);
			pop(stack);
			}
			else
			{
			while(top!=-1&&precd(stacktop(stack))>=precd(symb))
			postfix[j++]=pop(stack);
			push(stack,symb);
			}
	}
		while(top!=-1)
		postfix[j++]=pop(stack);
		postfix[j]='\0';
}
void main()
{
	char infix[50];
	char postfix[50],stack[40],ele,op;
	printf("Enter a valid infix expression\n");
	scanf("%s",infix);
	infix_postfix(infix,postfix);
	printf("The postfix expression is\n");
	printf("%s\n",postfix);
}
5.
#include<stdio.h>
#include<math.h>
#include<string.h>

void push(float[],float);
float pop(float[]);
int top;

float Eval_postfix(char postfix[])
{
	float opndstk[50],op1,op2;
	int i;char symb;
	top=-1;
	for(i=0;postfix[i]!='\0';i++)
	{
		symb=postfix[i];
		if(isdigit(symb))
		push(opndstk,(float)(symb-'0'));
		else
		{
			op2=pop(opndstk);
			op1=pop(opndstk);
			switch(symb)
			{
				case'*':push(opndstk,op1*op2);
				break;
				case'/':push(opndstk,op1/op2);
				break;
				case'+':push(opndstk,op1+op2);
				break;
				case'-':push(opndstk,op1-op2);
				break;
				case'$':push(opndstk,pow(op1,op2));
				break;
			}
		}
	}
	return(pop(opndstk));
}
void push(float opndstk[],float value)
{
	opndstk[++top]=value;
}
float pop(float opndstk[])
{
	return(opndstk[top--]);
}
void main()
{
	char postfix[50];
	float fvalue;
	printf("enter the valid expression:\n");
	scanf("%s",postfix);
	fvalue=Eval_postfix(postfix);
	printf("\n Evaluated value is:%.2f",fvalue);
}
b. 
#include<stdio.h>
#include<math.h>

void tower(int n, int source, int temp,int destination)
{
	if(n==0)
	return;
	tower(n-1, source, destination, temp);
	printf("\nMove disc %d from %c to %c", n, source, destination);
	tower(n-1, temp, source, destination);
}
void main()
{
	int n;
	printf("\nEnter the number of discs: \n");
	scanf("%d", &n);
	tower(n, 'A', 'B', 'C');
	printf("\n\nTotal Number of moves are: %d",(int)pow(2,n)-1);
}
6.
#include <stdio.h>
#include<stdlib.h>
#include<stdio_ext.h>
#define MAX 3

char cq[MAX];
int front = -1, rear = -1;

void insert(char);
void delete();
void display();
void main()
{
             int ch;
             char item;
             while(1)
             {
                            printf("\n\n~~Main Menu~~");
                            printf("\n==> 1. Insertion and Overflow Demo");
                            printf("\n==> 2. Deletion and Underflow Demo");
                            printf("\n==> 3. Display");
                            printf("\n==> 4. Exit");
                            printf("\nEnter Your Choice: ");
                            scanf("%d", &ch);
                            __fpurge(stdin);
                           switch(ch)
                          {
                                           case 1:        printf("\n\nEnter the element to be inserted: ");
                                                              scanf("%c", &item);
                                                              insert(item);
                                                              break;
                                           case 2:        delete();
                                                              break;
                                           case 3:        display();
                                                              break;
                                            case 4:       exit(0);
                                            default:      printf("\n\nPlease enter a valid choice");
                            }
               }
}

void insert(char item)
{
                 if(front == (rear+1)%MAX)
                 {
                              printf("\n\n~~Circular Queue Overflow~~");
                 }
                 else
                 {
                             if(front == -1)
                                             front = rear = 0;
                             else
                                              rear = (rear+1)%MAX;
                             cq[rear] = item;
                  }
}

void delete()
{
                char item;
                if(front == -1)
                {
                              printf("\n\n~~Circular Queue Underflow~~");
                }
                else
                {
                               item = cq[front];
                               printf("\n\nDeleted element from the queue is: %c ",item );
                               

                               if(front == rear) //only one element
                                                front = rear = -1;
                               else
                                               front = (front+1)%MAX;
                 }
}


void display ()
{
                   int i ;
                   if(front == -1)
                   {
                                 printf("\n\nCircular Queue Empty");
                   }
                   else
                   {
                                printf("\nCircular Queue contents are:\n");
                                printf("Front[%d]-> ", front);
                               for(i = front; i != rear ; i = (i+1)%MAX)
                               {
                                                   printf(" %c", cq[i]);
                               }
                               printf(" %c", cq[i]);
                               printf(" <-[%d]Rear", rear);
                    }
}
7.
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct Node
{
			char usn[30];
			char name[30];
			char branch[5];
			int sem;
			char phno[10];
			struct Node *link;
};
struct Node * getnode()
{
			struct Node *p;
			p=(struct Node *)malloc(sizeof(struct Node)); //Create  NODE
			printf("\nEnter USN, Name, Branch, Sem, Ph.No\n");
			p->link = NULL;
			fflush(stdin);
			scanf("%s%s%s%d%s", p->usn,p->name,p->branch,&p->sem,p->phno);
			return p;
}

struct Node *InsertF(struct Node *first) // Insert @ Front
{
			struct Node *p;
			p = getnode();
			if(first==NULL)
			first = p;
			else
			{
	 			p->link =first;
	  			first = p;
			}
      	return first;
}
struct Node *InsertR(struct Node *first)  // Insert @ End
{
    		struct Node *p;
			if(first==NULL)
			first = getnode();
			else
			{
	  			for(p=first; p->link!=NULL; p=p->link);
	  			p->link = getnode();
			}
      	return first;
}
struct Node *DeleteF(struct Node *first)  // delete @ Front
{     
			struct Node *p;
			if(first==NULL)
			printf("\nLIST IS EMPTY");
       	else
			{
				p=first;
				first=first->link;
				printf("\nDeleted Record is:\n");
				printf("%s\t%s\t%s\t%d\t%s\n",p->usn,p->name,p->branch,p->sem,p->phno);
				free(p);
			}
			return first;
}
struct Node *DeleteR(struct Node *first)  // delete @ End
{   
			struct Node *p,*prev;
			if(first==NULL)
			printf("\nList is Empty\n");
       	else
       	{    
				prev = NULL;     // prev follows p
				for(p=first;p->link!=NULL;prev=p, p=p->link); //Navigate list till end
				if(prev ==NULL)
				first = NULL;
				else
				prev->link=NULL;
				printf("\nDeleted Record is:\n");
				printf("%s\t%s\t%s\t%d\t%s\n",p->usn,p->name,p->branch,p->sem,p->phno);
				free(p);
			}
			return first;
}
void Display(struct Node *first)
{
			struct Node *p;
			int cnt = 0;
			if(first==NULL)
			{
				printf("\nList is Empty\n");
				return;
			}
			printf("\nStatus of List:\n");
			for(p=first;p!=NULL;p=p->link)
			{
				printf("%s\t%s\t%s\t%d\t%s\n",p->usn,p->name,p->branch,p->sem,p->phno);
				cnt++;
			}
			printf("Total Number of Records: %d", cnt);
}
void  main()
{
			int ch;
			struct Node *first = NULL; //initialize list as empty
			clrscr();
			while(1)
			{
	printf("\n1:INSERT-Front\n2:INSERT-End\n3:DELETE-Front\n4:DELETE-    End\n5:DISPLAY\n6:EXIT\n");
			printf("Enetr your choice\n");
			scanf("%d", &ch);
			switch(ch)
			{
				case 1: first=InsertF(first);
				break;
				case 2: first=InsertR(first);
				break;
				case 3: first=DeleteF(first);
				break;
				case 4: first=DeleteR(first);
				break;
				case 5: Display(first); break;
				case 6: exit(0);
			}
		}
	}
8.
  #include<stdlib.h>
#include<stdio.h>

struct Node
{
struct Node *llink;
int ssn;
char name[20];
char dept[10];
char desig[10];
unsigned sal;
char pno[12];
struct Node *rlink;
};
struct Node *first=NULL;
struct Node *last =NULL;
struct Node * getnode()
{
	struct Node *p;
	p=(struct Node *)malloc(sizeof(struct Node)); //Create  NODE
	printf("\nEnter SSN, Name,Dept.,Desig.,Salry, Ph.No\n");
	p->llink = p->rlink=NULL;
	fflush(stdin);
	scanf("%d%s%s%s%d%s", &p->ssn,p->name,p->dept,p->desig,&p->sal,p->pno);
	return p;
}
void InsertFront(void)
{
	struct Node *p;
	p=getnode();
	if(first==NULL)
	first=last=p;
	else
	{   	p->rlink=first;
		first->llink=p;
		first=p;
	}
}
void InsertLast()
{
	struct Node *p;
	p=getnode();
	if(first==NULL)
	first=last=p;
	else
	{
		last->rlink = p;
		p->llink = last;
		last =p;
	}
 }
void DeleteFront()
{
	struct Node *p = first;
	if(first ==NULL)
	{
	     printf("List is Empty...\n");
	     return;
	}
	if(first == last) /*single node list*/
	first =last = NULL;
	else
	{
		first = first->rlink;
		first->llink = NULL;
	}
	printf("Deleted Record is:\n");
	printf("<%d\t%s\t%s\t%s\t%d\t%s>\n", p->ssn,p->name,p->dept,p->desig,p->sal,p->pno);
	free(p);
}
void DeleteLast()
{
	struct Node *p = last;
	if(first ==NULL)
	{
	     printf("List is Empty...\n");
	     return;
	}
	if(first == last) /*single node list*/
	first =last = NULL;
	else
	{
	     last = last->llink;
	     last->rlink = NULL;
	}
	printf("Deleted Record is:\n");
	printf("<%d\t%s\t%s\t%s\t%d\t%s>\n", p->ssn,p->name,p->dept,p->desig,p->sal,p->pno);
	free(p);
}
void DispForward()
{   	struct Node *p;
	int cnt = 0;
	if(first==NULL)
	{
		printf("\nList is empty...\n");
		return;
	}
	printf("\nStatus of List...\n");
	for(p = first; p!=NULL; p=p->rlink,cnt++)
	printf("<%d\t%s\t%s\t%s\t%d\t%s>\n", p->ssn,p->name,p->dept,p->desig,p->sal,p->pno);
	printf("Total number of elements in List: %d\n", cnt);
}
void main()
{
	int ch;
	
	while(1)
	{
		printf("\n1:InsertFront\n2:InsertLast\n3:DeleteFront\n4:DeleteLast\n5:Display\n6:Exit");
		printf("\n\nEnter your choice:");
		fflush(stdin);
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:InsertFront(); break;
			case 2:InsertLast();  break;
			case 3:DeleteFront(); break;
			case 4:DeleteLast();  break;
			case 5:DispForward(); break;
			case 6:exit(0);
		}
	}
}
9.
